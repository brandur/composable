doctype 5

html
  head
    title= "Composable Apps With a First-class API"

    link href="/assets/application.css" media="screen" rel="stylesheet" type="text/css"
    /link href="http://fonts.googleapis.com/css?family=EB+Garamond|PT+Serif" rel="stylesheet" type="text/css"

  body.impress-not-supported
    #impress data-transition-duration="500"
      - x, y = 0, 0

      .step data-x="#{x}" data-y="#{y}" data-scale="2"
        p @brandur

      .step#agenda data-x="#{x}" data-y="#{y += 2000}" data-scale="2"
        .floating
          h3 Agenda
          ol
            li
              a href="#a-tale-of-composition" A tale of composition
            li
              a href="#app-composition" App composition
            li
              a href="#lessons-learnt" Lessons learnt

      .step#a-tale-of-composition data-x="#{x}" data-y="#{y += 2000}" data-scale="2"
        h2 A Tale of<br>Composition

      .step.slide data-x="#{x}" data-y="#{y += 600}"
        h3 Heroku's API Team
        ul
          li
            | If you've used the CLI, you've used the API
            pre
              | heroku list
            pre
              | GET https://api.heroku.com/apps
          li
            | Try it!
            pre
              | # you can your API key from ~/.netrc
                curl --user ":$API_KEY" -i https://api.heroku.com/apps

      .step data-x="#{x}" data-y="#{y += 850}"
        .floating
          p We were also <strong>in charge of this</strong>.
        #api-screenshot

      .step.slide data-x="#{x}" data-y="#{y += 850}"
        h3 Core
        ul
          li A Rails app
          li Then, a <strong>BIG RAILS APP</strong>
          li Severe impact on development velocity and effort

      .step.slide data-x="#{x}" data-y="#{y += 850}"
        h3 We broke things out.
        ul
          li Process management
          li Billing
          li Addons
          li Kernel layer infrastructure management
          li Domain management

      .step.floating data-x="#{x}" data-y="#{y += 850}" data-scale="2"
        #butc
          h3 BUTC
          p <strong>B</strong>reak <strong>u</strong>p <strong>t</strong>he <strong>c</strong>ore

      .step.slide data-x="#{x}" data-y="#{y += 850}"
        h3 Still too big
        ul
          li The goal is something small and agile
          li
            | Rails taught us to design an API like this:
            pre.language-ruby
              | responds_to do |format|
                  format.json { render :json => @apps }
                  format.html
                end
          li But we're an API, why should the web component get special treatment?

      .step data-x="#{x}" data-y="#{y += 850}"
        .floating
          h3 Introducing Dashboard
        #dashboard-screenshot

      .step.slide data-x="#{x}" data-y="#{y += 850}"
        h3 Dashboard Implementation
        ul
          li Rails
          li
            | Heroku.rb
            ul
              li The same backend that handles API calls for the CLI
            pre.language-ruby
              | # GET /apps
                def get_apps
                  request(
                    :expects  => 200,
                    :method   => :get,
                    :path     => "/apps"
                  )
                end

      .step.slide data-x="#{x}" data-y="#{y += 850}"
        p API calls happen on the backend.
        pre.language-ruby
          | class AppsController < ApplicationController
              def index
                @apps = @api.get_apps
              end
            end

      .step.slide data-x="#{x}" data-y="#{y += 850}"
        h3 Where's the fat client?
        ul
          li We enjoy the Ruby experience
          li
            | Puts all the elements in place for a fat client
            ul
              li Graceful degredation
          li
            | Backbone still recommends bootstrapped models
            pre.language-javascript
              | &lt;script&gt;
                  var Apps = new Backbone.Collection;
                  Apps.reset(<%= @apps.to_json %>);
                &lt;/script&gt;

      .step.slide data-x="#{x}" data-y="#{y += 850}"
        h3 Metrics
        ul
          li
            | Dashboard
            ul
              li + 4500 LOCs (3200 Ruby + 1300 templates)
          li
            | Core
            ul
              li 66k LOCs (61k Ruby + 5k templates)
              li Down to 55k LOCs (55k Ruby)
              li - 11k (~15%)
              li Not the final win, but we'll take it

      .step.slide data-x="#{x}" data-y="#{y += 850}"
        h3 Our API is now an API
        p @todo: diagram of divergence

      .step data-x="#{x}" data-y="#{y += 850}"
        .floating
          h3 Heroku Manager
        #manager-screenshot

      .step.slide data-x="#{x}" data-y="#{y += 850}"
        h3 A good API is a reusable API
        ul
          li
            | Manager is further composed into two tiers
            ul
              li API
              li Web
          li Core's API separately consumed by Dashboard, Manager, and the CLI

      .step#app-composition data-x="#{x += 1000}" data-y="#{y -= 800}" data-scale="4" data-rotate="-90"
        h2 App<br>Composition

      .step.slide data-x="#{x}" data-y="#{y -= 1600}" data-rotate="-90"
        h3 Composability
        / @todo: real diagram
        pre
          | API     <-      CLI + developers
             |
             v
            Web     <-      Other users

      .step.slide data-x="#{x}" data-y="#{y -= 850}" data-rotate="-90"
        h3 Service oriented architecture
        ul
          li Loosely coupled components
          li Encourages strong contracts (they're a necessity)
          li Independent scaling of each service
          li API is a critical factor the increasingly important mobile component

      .step.slide data-x="#{x}" data-y="#{y -= 850}" data-rotate="-90"
        h3 Rails as frontend
        ul
          li
            | Great at interface
            ul
              li Template options
              li Asset pipeline
          li Maintenance of state through sessions
          li Security considerations: XSS/CSRF/etc.

      .step.slide data-x="#{x}" data-y="#{y -= 850}" data-rotate="-90"
        h3 Rails as API
        ul
          li Helpers/views become less useful
          li ActiveRecord pretty good, but it's now decoupled
          li <code>ActiveRecord::Serialization#to_json</code> is a bad idea when strong contracts are important
          li
            | APIs are about verbs and nouns
            ul
              li A routing DSL is an unneeded layer of abstraction

      .step.slide data-x="#{x}" data-y="#{y -= 850}" data-rotate="-90"
        h3 Sinatra as API
        pre.language-ruby
          | get "/facts/:id" do |id|
              fact = Fact.first(id: id.to_i)
              [200, encode_json(fact)]
            end
            
            post "/facts" do
              fact = Fact.new(fact_params)
              fact.save
              [201, encode_json(fact)]
            end
        ul
          li The API's verbs and nouns are explicit
          li Beyond a trivial app, forces consideration of project structure
          li Use the exact Rack middleware stack you need

      .step.slide data-x="#{x}" data-y="#{y -= 850}" data-rotate="-90"
        h3 Grape as API
        pre.language-ruby
          | class Facts::API < Grape::API
              version 'v0', using: :header
              
              resources :facts do
                get ":id" do
                  fact = Fact.first(id: params[:id].to_i)
                  encode_json(fact)
                end
              
                post do
                  fact = Fact.create(fact_params)
                  encode_json(fact)
                end
              end
            end
        ul
          li Patterns for versioning, parameter validation and coercion, and endpoint descriptions

      .step.slide data-x="#{x}" data-y="#{y -= 850}" data-rotate="-90"
        h3 First-class APIs
        ul
          li We're not post-Rails, but we did move it up a layer

      .step.slide data-x="#{x}" data-y="#{y -= 850}" data-rotate="-90"
        h3 Organization
        ul
          li
            | Smaller and more specialized teams
            ul
              li <strong>Before:</strong> three backend people, a designer, and a handful of frontend engineers
              li <strong>After:</strong> API is three backend people; Dashboard is a designer and a frontend engineer

      .step.slide data-x="#{x}" data-y="#{y -= 850}" data-rotate="-90"
        h3 Happiness
        ul
          li Designers and frontend people get to work on a thin web app
          li Backend people don't have to worry about CSS floats
          li Internal self-service

      .step.slide data-x="#{x}" data-y="#{y -= 850}" data-rotate="-90"
        h3 Flexibility
        ul
          li Use an agnostic protocol (stay HTTP)
          li Then use the right tool for the right job
          / @todo: real diagram
          pre
            | --> Ruby (psmgr)       --> Ruby (API)   --> Ruby (Dashboard)
              --> Erlang (logplex)                    --> Scala (Manager API) --> Ruby (Manager web)

      .step#lessons-learnt data-x="#{x += 1000}" data-y="#{y}" data-scale="2" data-rotate-y="45"
        h2 Lessons Learnt

      .step.slide data-x="#{x}" data-y="#{y += 850}" data-rotate-y="45"
        h3 Stubs
        ul
          li More pieces in the system make development and testing harder
          li You've just composed your apps to streamline your work; setup should also be streamlined

      .step.floating data-x="#{x}" data-y="#{y += 850}" data-rotate-y="45"
        h3 We started with this.
        p But we don't recommend it.
        pre.language-ruby
          | class AppsController < ApplicationController
              def index
                @apps = if production?
                  @api.get_apps
                else
                  []
                end
              end
            end

      .step.slide data-x="#{x}" data-y="#{y += 850}" data-rotate-y="45"
        h3 excon-artifice
        ul
          li Patches Excon to route calls to a Rack app
          li Based on Wycat's Artifice, that does the same thing for Net::HTTP
          li Easy stubbing for test purposes
        pre.language-ruby
          | stub(Config).billing_api { "https://billing-api.localhost" }
            stub(Config).process_api { "https://process-api.localhost" }
            
            # stub with fully functional Rack apps
            Artifice::Excon.activate_for(Config.billing_api,
              BillingAPIStub.new)
            Artifice::Excon.activate_for(Config.process_api,
              ProcessAPIStub.new)

      .step.slide data-x="#{x}" data-y="#{y += 850}" data-rotate-y="45"
        h3 And you get Rack apps!
        pre.language-bash
          | web:         thin start -R config.ru -p $PORT
            billing_api: thin start -R stubs/billing_api.ru -p $PORT
            process_api: thin start -R stubs/process_api.ru -p $PORT
        p These apps are platform deployable.

      .step.slide data-x="#{x}" data-y="#{y += 850}" data-rotate-y="45"
        h3 Platform
        p Use Heroku. It's obviously the right decision.

      .step.slide data-x="#{x}" data-y="#{y += 850}" data-rotate-y="45"
        h3 ... but if you can't
        ul
          li Pain to deploy a new app must be low
          li Pain to deploy a new app formation should be low
          li 
            | Easy reconfiguration
            ul
              li Web can point to a production API or a deployed stub

      .step.floating data-x="#{x}" data-y="#{y += 850}" data-rotate="45" data-rotate-y="45"
        #about
          h3 @brandur
          p brandur@mutelight.org
          ul.notes
            li * <strong>Stunning</strong> effects by <a href="http://bartaz.github.com/impress.js">Impress.js</a>
            li * Powered by <strong>Heroku</strong>; <a href="https://github.com/brandur/composable">source code</a>

      //.step#overview data-x="1000" data-y="10500" data-scale="6" data-rotate="-90"
      .step#overview data-x="1000" data-y="10500" data-scale="9" data-rotate="-90"

    script src="/assets/application.js" type="text/javascript"
    javascript:
      impress().init()
